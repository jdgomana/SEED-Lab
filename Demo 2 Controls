#include <Wire.h>
#include <math.h>

/* ===================== Pins (UNO) ===================== */
#define MY_ADDR 8
const int EN       = 4;          // motor driver enable (HIGH = on)

/* Make index 0 = LEFT, index 1 = RIGHT (your wiring is swapped) */
const int MDIR[2]  = {8, 7};     // {LEFT, RIGHT} direction pins  (swapped)
const int MPWM[2]  = {10, 9};    // {LEFT, RIGHT} PWM pins        (swapped)

/* Encoders */
const int ENC_A[2] = {2, 3};     // left A (INT0), right A (INT1)
const int ENC_B[2] = {5, 6};     // left B, right B
const int LED_PIN  = LED_BUILTIN;

/* ================= Geometry / scaling ================= */
long  CPR[2]       = {3200, 3200};
float radPerCnt[2] = {0, 0};     // [rad / count]

// Signs: forward spin should make counts/angles increase
volatile int ENC_SIGN[2]  = {+1, -1};  // encoder counts positive for forward spin
int MOTOR_SIGN[2]         = {-1, +1};  // LEFT forward=LOW, RIGHT forward=HIGH

// Robot geometry (EDIT to your bot)
const float R_wheel = 0.0762f;   // wheel radius [m]   (== 3.0 in)
const float L_axle  = 0.3505f;   // axle length [m]    (== 13.8 in)

/* ---------- Odometry calibration ---------- */
// Tune these two numbers so encoders match the real world.
const float DIST_K = 1.00f;      // distance scale (start 1.00; tune with straight drive)
const float YAW_K  = 1.78f;      // yaw scale (from your test)

/* ================== Loop timing ======================= */
const unsigned long Ts_ms = 10;     // 100 Hz
const float Ts_s = Ts_ms / 1000.0f;

/* ========== Inner (velocity) PI ======================= */
// Start with P-only; add small Ki later if needed
float Kp[2]    = {12.0f, 12.0f};
float Ki[2]    = {0.0f,  0.0f};
float integVel[2] = {0, 0};
float VEL_CAP = 1.57f;            // (unused cap placeholder)

/* ========= Outer (position) PI (per wheel) ============ */
// kept defined but not used directly here
float Kp_pos[2] = {4.0f, 4.0f};
float Ki_pos[2] = {0.0f, 0.0f};
float integPos[2] = {0, 0};

const float POS_TOL_HOLD = 0.02f;
const float POS_TOL_EXIT = 0.06f;
const float VEL_TOL      = 0.10f;   // rad/s
bool hold[2] = {false, false};

/* ================= Electrical ========================= */
const float VBATT = 7.5f;
const float VMAX  = VBATT;          // allow full headroom
const float U_DEADBAND = 0.05f;     // let small voltages through

/* === Anti-chatter helpers for velocity loop === */
float u_cmd[2] = {0,0};             // slewed voltage command state
const float U_MIN_RUN = 0.60f;      // min volts to overcome stiction
const float DU_MAX    = 0.25f;      // max voltage change per loop (~15 V/s @100Hz)
const float SPEED_EPS = 0.15f;      // forbid reverse torque near zero speed

/* ================= Encoder state ====================== */
volatile long cnt[2] = {0, 0};
static long cnt_prev[2] = {0, 0};
float theta[2] = {0, 0};           // cumulative wheel angle [rad]
float omega_f[2] = {0, 0};         // filtered wheel speed [rad/s]
const float fc_hz = 20.0f;         // slightly faster filter
const float a_lp = expf(-(2.0f * PI) * fc_hz * Ts_s);

/* ====== Desired targets (per wheel) =================== */
float desired_pos[2]   = {0, 0};   // absolute wheel radians
float desired_speed[2] = {0, 0};   // rad/s

/* ============ Robot-level pose (for reference) ======== */
float p_m  = 0.0f;                 // distance traveled [m]
float phi_r = 0.0f;                // heading [rad]

/* ============ Steering outer loops (TURN PID on) ====== */
// TURN/heading PID (used in some parts; still available)
float Kp_phi_o = 1.0f;
float Ki_phi_o = 0.20f;            // <= Ki ON (small); we clamp its integral below
float Kd_phi_o = 1.4f;

float ephi_int = 0.0f;
const float EPHI_INT_MAX = 0.4f;   // clamp on integral state (tune if needed)

// Forward distance P+I (mild)
float Kp_p_o   = 1.0f;
float Ki_p_o   = 0.25f;
float ep_int   = 0.0f;

float vp_cmd = 0.0f; // translational speed [m/s]
float w_cmd  = 0.0f; // yaw rate [rad/s]
const float VP_MAX = 0.80f;  // [m/s]
const float W_MAX  = 0.45f;  // [rad/s] tighter to reduce overshoot

/* ===== Quiet windows ===== */
const float W_QUIET  = 0.02f;
const float VP_QUIET = 0.04f;
const float U_QUIET  = 0.0f;
const float DES_SPEED_QUIET = 0.05f;

/* ===== Mission inputs (unused now, but kept) ===== */
float DESIRED_ANGLE_DEG = 90.0f;   // was used for scripted motion
float DESIRED_DIST_M    = 0.9144f; // was used for scripted motion

/* ============ Camera input (from Raspberry Pi) ============ */
volatile bool camNew = false;
char camBuf[32];

float camAngleDeg   = 0.0f;  // A##.# from Pi
float camDistanceFt = 0.0f;  // D##.# from Pi
char  camArrow      = 'N';   // 'L', 'R', or 'N'

unsigned long camLastMs = 0;         // last time we got a camera update
const unsigned long CAM_TIMEOUT_MS = 300;  // ms until we treat marker as "lost"

/* ===== Camera-phase machine ===== */
enum CamPhase { CAM_SEARCH, CAM_APPROACH, CAM_ARROW_TURN, CAM_IDLE };
CamPhase camPhase = CAM_SEARCH;

const float TARGET_DIST_FT = 1.0f;     // stop ~1 ft from marker
const float ANGLE_TOL_DEG  = 0.5f;     // angle ok if within ±.5°
const float DIST_TOL_FT    = 0.1f;     // distance ok within ±0.1 ft

unsigned long arrowTurnStartMs = 0;
const unsigned long ARROW_TURN_MS = 1000;  // arrow turn duration [ms]
const float W_ARROW = 0.4f;                // yaw rate [rad/s] for arrow turn

/* ================== Helpers ========================== */
static inline int V2PWM(float u){
  int p = (int)((fabs(u)/VBATT) * 255.0f + 0.5f);
  if (p < 0)   p = 0;
  if (p > 255) p = 255;
  return p;
}

static inline void driveSigned(int i, float u){
  float u_eff = MOTOR_SIGN[i] * u;
  digitalWrite(MDIR[i], (u_eff >= 0.0f) ? HIGH : LOW);
  if (fabs(u_eff) < U_DEADBAND) analogWrite(MPWM[i], 0);
  else                          analogWrite(MPWM[i], V2PWM(u_eff));
}

static inline void stopMotor(int i){ analogWrite(MPWM[i], 0); }
static inline void stopAllMotors(){ for(int i=0;i<2;i++) stopMotor(i); }

/* ======================= ISRs ========================= */
void ISR_leftA() {
  int A = digitalRead(ENC_A[0]);
  int B = digitalRead(ENC_B[0]);
  cnt[0] += ENC_SIGN[0] * ((A != B) ? +1 : -1);
}
void ISR_rightA() {
  int A = digitalRead(ENC_A[1]);
  int B = digitalRead(ENC_B[1]);
  cnt[1] += ENC_SIGN[1] * ((A != B) ? +1 : -1);
}

/* ================== I2C receive ==================== */
// Expect messages like: "A-12.3D4.5L"
void onRx(int howMany){
  int i = 0;
  while (Wire.available() && i < (int)sizeof(camBuf) - 1) {
    camBuf[i++] = Wire.read();
  }
  camBuf[i] = '\0';

  if (i > 0) {
    float a, d;
    char arrow = 'N';

    int parsed = sscanf(camBuf, "A%fD%f%c", &a, &d, &arrow);
    if (parsed >= 2) {  // got angle + distance
      camAngleDeg   = a;
      camDistanceFt = d;
      if (parsed == 3) {
        camArrow = arrow;
      } else {
        camArrow = 'N';
      }
      camNew = true;
      camLastMs = millis();
    }
  }
}

/* ===================== Setup ========================== */
void setup(){
  pinMode(EN, OUTPUT); digitalWrite(EN, HIGH);
  for(int i=0;i<2;i++){
    pinMode(MDIR[i], OUTPUT); digitalWrite(MDIR[i], HIGH);
    pinMode(MPWM[i], OUTPUT); analogWrite(MPWM[i], 0);
    pinMode(ENC_A[i], INPUT_PULLUP);
    pinMode(ENC_B[i], INPUT_PULLUP);
  }
  pinMode(LED_PIN, OUTPUT); digitalWrite(LED_PIN, LOW);

  attachInterrupt(digitalPinToInterrupt(ENC_A[0]), ISR_leftA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_A[1]), ISR_rightA, CHANGE);

  for(int i=0;i<2;i++) radPerCnt[i] = (2.0f * PI) / (float)CPR[i];

  Wire.begin(MY_ADDR);
  Wire.onReceive(onRx);

  Serial.begin(115200);
  Serial.println(F("# thetaL(rad)\tthetaR(rad)\tp_m(m)\tphi_r(rad)\tcntL\tcntR\tAL/BL\tAR/BR"));
}

/* ===================== Main loop ====================== */
void loop(){
  static unsigned long tLast = millis();
  unsigned long now = millis();
  if (now - tLast < Ts_ms) return;
  tLast = now;

  // Snapshot counts
  long c[2]; noInterrupts(); c[0]=cnt[0]; c[1]=cnt[1]; interrupts();
  long dC[2] = { c[0]-cnt_prev[0], c[1]-cnt_prev[1] };
  cnt_prev[0]=c[0]; cnt_prev[1]=c[1];

  // Wheel angles/speeds
  float dtheta[2];
  for(int i=0;i<2;i++){
    dtheta[i]  = dC[i] * radPerCnt[i];
    theta[i]  += dtheta[i];
    float omega = dtheta[i] / Ts_s;
    omega_f[i]  = a_lp * omega_f[i] + (1.0f - a_lp) * omega;
  }

  // Robot pose from encoders (with calibration scales)
  float dp   = DIST_K * (0.5f * R_wheel * (dtheta[0] + dtheta[1]));
  float dphi = YAW_K  * ((R_wheel / L_axle) * (dtheta[1] - dtheta[0])); // R minus L
  p_m  += dp;
  phi_r += dphi;

  // ===== CAMERA-BASED CONTROL =====

  // Default commands
  vp_cmd = 0.0f;
  w_cmd  = 0.0f;

  // Check if camera data is fresh
  bool camFresh = (millis() - camLastMs) <= CAM_TIMEOUT_MS;

  if (!camFresh) {
    // Lost marker: stop and go back to SEARCH
    camPhase = CAM_SEARCH;
    vp_cmd = 0.0f;
    w_cmd  = 0.0f;
  } else {
    // Convert camera data
    float angleRad   = camAngleDeg * (PI / 180.0f);
    float distErrFt  = camDistanceFt - TARGET_DIST_FT;
    float distErrM   = distErrFt * 0.3048f;  // ft -> m

    // simple proportional gains (tune!)
    const float Kp_angle_cam = 1.5f;
    const float Kp_dist_cam  = 0.8f;

    switch (camPhase) {
      case CAM_SEARCH:
        // Rotate to center the marker (angle -> 0)
        w_cmd  = Kp_angle_cam * angleRad;
        vp_cmd = 0.0f;

        if (w_cmd >  W_MAX) w_cmd =  W_MAX;
        if (w_cmd < -W_MAX) w_cmd = -W_MAX;

        // If angle is small and we're still more than 1 ft away, go to approach
        if (fabs(camAngleDeg) < ANGLE_TOL_DEG &&
            camDistanceFt > TARGET_DIST_FT + DIST_TOL_FT) {
          camPhase = CAM_APPROACH;
        }
        break;

      case CAM_APPROACH:
        // Move toward the marker until distance ~ 1 ft, keep it centered
        vp_cmd = Kp_dist_cam  * distErrM;
        w_cmd  = Kp_angle_cam * angleRad;

        if (vp_cmd >  VP_MAX) vp_cmd =  VP_MAX;
        if (vp_cmd < -VP_MAX) vp_cmd = -VP_MAX;
        if (w_cmd  >  W_MAX ) w_cmd  =  W_MAX;
        if (w_cmd  < -W_MAX ) w_cmd  = -W_MAX;

        if (fabs(vp_cmd) < VP_QUIET) vp_cmd = 0.0f;
        if (fabs(w_cmd)  < W_QUIET ) w_cmd  = 0.0f;

        // If we're close enough and aligned enough, decide what to do next
        if (fabs(distErrFt) < DIST_TOL_FT &&
            fabs(camAngleDeg) < ANGLE_TOL_DEG) {
          vp_cmd = 0.0f;
          w_cmd  = 0.0f;

          if (camArrow == 'L' || camArrow == 'R') {
            camPhase = CAM_ARROW_TURN;
            arrowTurnStartMs = millis();
          } else {
            camPhase = CAM_IDLE;
          }
        }
        break;

      case CAM_ARROW_TURN:
        // Rotate in place according to arrow direction for fixed time
        vp_cmd = 0.0f;
        if (camArrow == 'L')      w_cmd = +W_ARROW;
        else if (camArrow == 'R') w_cmd = -W_ARROW;
        else                      w_cmd = 0.0f;

        if (millis() - arrowTurnStartMs >= ARROW_TURN_MS) {
          vp_cmd = 0.0f;
          w_cmd  = 0.0f;
          camPhase = CAM_IDLE;
        }
        break;

      case CAM_IDLE:
      default:
        vp_cmd = 0.0f;
        w_cmd  = 0.0f;
        break;
    }
  }

  // ===== Map body commands to wheel speeds =====
  float vL = vp_cmd - 0.5f * L_axle * w_cmd; // m/s
  float vR = vp_cmd + 0.5f * L_axle * w_cmd; // m/s
  desired_speed[0] = vL / R_wheel;           // rad/s
  desired_speed[1] = vR / R_wheel;           // rad/s

  /* ===== Inner PI (velocity → signed voltage) with anti-chatter ===== */
  float uV[2] = {0,0};
  for (int i=0; i<2; i++){
    const float w_des = desired_speed[i];
    const float w_mea = omega_f[i];
    float e_vel = w_des - w_mea;

    float u_uns = Kp[i]*e_vel + Ki[i]*integVel[i];

    // simple anti-windup
    if (fabs(u_uns) < VMAX) {
      integVel[i] += e_vel * Ts_s;
    }

    if (u_uns >  VMAX) u_uns =  VMAX;
    if (u_uns < -VMAX) u_uns = -VMAX;

    // ONE-SIDED DRIVE: forbid reverse torque near zero speed
    if (w_des > SPEED_EPS && u_uns < 0.0f) u_uns = 0.0f;
    if (w_des < -SPEED_EPS && u_uns > 0.0f) u_uns = 0.0f;

    // MIN-RUN: beat stiction
    if (u_uns != 0.0f && fabs(u_uns) < U_MIN_RUN) {
      u_uns = (u_uns > 0.0f) ? +U_MIN_RUN : -U_MIN_RUN;
    }

    // SLEW LIMIT
    float du = u_uns - u_cmd[i];
    if (du >  DU_MAX) du =  DU_MAX;
    if (du < -DU_MAX) du = -DU_MAX;
    u_cmd[i] += du;

    uV[i] = u_cmd[i];
    driveSigned(i, u_cmd[i]);
  }

  /* ===== Telemetry ===== */
  static unsigned long lastPrint = 0;
  if (now - lastPrint >= 50){
    lastPrint = now;
    int aL=digitalRead(ENC_A[0]), bL=digitalRead(ENC_B[0]);
    int aR=digitalRead(ENC_A[1]), bR=digitalRead(ENC_B[1]);
    Serial.print(theta[0],5); Serial.print('\t');
    Serial.print(theta[1],5); Serial.print('\t');
    Serial.print(p_m,5);      Serial.print('\t');
    Serial.print(phi_r,5);    Serial.print('\t');
    Serial.print((long)cnt[0]); Serial.print('\t');
    Serial.print((long)cnt[1]); Serial.print('\t');
    Serial.print(aL); Serial.print(aL?"H":"L"); Serial.print('/');
    Serial.print(bL); Serial.print(bL?"H":"L"); Serial.print('\t');
    Serial.print(aR); Serial.print(aR?"H":"L"); Serial.print('/');
    Serial.println(bR);
  }
}
